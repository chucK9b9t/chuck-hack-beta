package me.chuck.chuckhack.mods.exploits;

import java.awt.Color;
import java.awt.Point;
import java.util.ArrayList;
import java.util.ConcurrentModificationException;

import me.chuck.chuckhack.Mod;
import me.chuck.chuckhack.events.bus.EventHandler;
import me.chuck.chuckhack.events.bus.Listener;
import me.chuck.chuckhack.events.other.PacketEvent;
import me.chuck.chuckhack.gui.Group;
import me.chuck.chuckhack.gui.Mode;
import me.chuck.chuckhack.gui.Setting;
import me.chuck.chuckhack.rendering.RenderUtil;
import me.chuck.chuckhack.utils.BlockUtil;
import net.minecraft.network.play.server.SPacketChunkData;
import net.minecraft.util.math.BlockPos;

public class NewChunks extends Mod {	
	public static ArrayList<Point> chunks = new ArrayList<Point>();
	
	public static Setting removeDistance = new Setting(Mode.INTEGER, "RemoveDistance", 150, "If you go this far from the rendered", "Chunks then it will remove it");
	
	public NewChunks() {
		super(Group.EXPLOITS, "NewChunks", "Highlights newly generated chunks");
	}
	
	@Override
	public void onDisabled() {
		chunks.clear();
	}
	
	@EventHandler
	private Listener<PacketEvent> onPacket = new Listener<>(event -> {
        if (event.packet instanceof SPacketChunkData) {
            SPacketChunkData packet = (SPacketChunkData)event.packet;
            if (!packet.isFullChunk())  {
            	Point chunk = new Point(packet.getChunkX() * 16, packet.getChunkZ() * 16);
            	
            	if (!chunks.contains(chunk)) {
            		chunks.add(chunk);
            	}
            }
        }
	});
	
	@Override
	public void onRenderWorld(float partialTicks) {
		try {
			Color c = Color.CYAN;
			ArrayList<Point> remove = new ArrayList<Point>();
			
	        for (Point chunk : chunks) {
	        	if (BlockUtil.distance(getPlayerPos(), new BlockPos(chunk.x, mc.player.posY, chunk.y)) < removeDistance.intValue()) {
	        		RenderUtil.draw2DRec(RenderUtil.getBB(new BlockPos(chunk.x, 0, chunk.y), 16), 1, c.getRed() / 255, c.getGreen() / 255, c.getBlue() / 255, 1f);
	        	} else {
	        		remove.add(chunk);
	        	}
	        }
	        
	        for (Point chunk : remove) {
	        	chunks.remove(chunk);
	        }
		} catch (ConcurrentModificationException ignored) {
			
		}
	}
}
