package me.chuck.chuckhack.mods.exploits;

import me.chuck.chuckhack.Mod;
import me.chuck.chuckhack.events.bus.EventHandler;
import me.chuck.chuckhack.events.bus.Listener;
import me.chuck.chuckhack.events.other.PacketEvent;
import me.chuck.chuckhack.events.player.PlayerDamageBlockEvent;
import me.chuck.chuckhack.events.player.PlayerMotionUpdateEvent;
import me.chuck.chuckhack.gui.Group;
import me.chuck.chuckhack.gui.Mode;
import me.chuck.chuckhack.gui.Setting;
import me.chuck.chuckhack.utils.InventoryUtil;
import me.chuck.chuckhack.utils.RotationUtil;
import net.minecraft.block.Block;
import net.minecraft.init.Blocks;
import net.minecraft.init.Items;
import net.minecraft.item.Item;
import net.minecraft.item.ItemAxe;
import net.minecraft.item.ItemSword;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.Vec3d;

public class MiningSpoof extends Mod {
	private static boolean noPick;

	public static Setting ignoreAxe = new Setting(Mode.BOOLEAN, "IgnoreAxe", false, "When holding axe it doesnt do it");
	public static Setting ignoreSword = new Setting(Mode.BOOLEAN, "IgnoreSword", false, "When holding sword it doesnt do it");
	
	public MiningSpoof() {
		super(Group.EXPLOITS, "MiningSpoof", "Allows you to mine blocks with your pickaxe", "Even when your not actually holding it", "Just start mining a block with this enabled", "And it will mine it as u would be using the pickaxe", "But you will not hold the pickaxe server/client side", "You need a pickaxe in ur hotbar for this to work");
	}
	
	@Override
	public void onDisabled() {
		noPick = false;
	}
	
	@EventHandler
	private Listener<PlayerMotionUpdateEvent> onMotionUpdate = new Listener<>(event -> {
		if (mc.player == null || !mc.gameSettings.keyBindAttack.isKeyDown() || mc.objectMouseOver.getBlockPos() == null) {
			return;
		}
		
		//Return if block cant be mined
		if (mc.world.getBlockState(mc.objectMouseOver.getBlockPos()).getBlockHardness(mc.world, mc.objectMouseOver.getBlockPos()) <= 0) {
			noPick = true;
			return;
		}
		
		if (!shouldMineSpoof()) {
			return;
		}
		
		int pickSlot = getPickaxeSlot();
		if (pickSlot == -1) {
			noPick = true;
			return;
		} else if (pickSlot == mc.player.inventory.currentItem) {
			return;
		}
	
		noPick = false;
		int oldSlot = mc.player.inventory.currentItem;
		
		//Switch to pickaxe
		mc.player.inventory.currentItem = pickSlot;
		mc.playerController.updateController();
		
		//Mine block
		mc.player.swingArm(EnumHand.MAIN_HAND);
		mc.playerController.onPlayerDamageBlock(mc.objectMouseOver.getBlockPos(), mc.objectMouseOver.sideHit);
		
		//Switch to old slot
		mc.player.inventory.currentItem = oldSlot;
		mc.playerController.updateController();
	});
	
	@EventHandler
	private Listener<PlayerDamageBlockEvent> playerDamageBlockEvent = new Listener<>(event -> {		
		if (mc.player.inventory.currentItem != getPickaxeSlot() && !noPick && shouldMineSpoof()) {
			event.cancel();
		}
	});
	
	public static boolean shouldMineSpoof() {
		//Check if player is holding an ignored item and then return
		Item held = mc.player.getHeldItemMainhand().getItem();
		if (ignoreAxe.booleanValue() && held instanceof ItemAxe || ignoreSword.booleanValue() && held instanceof ItemSword) {
			return false;
		}
		
		//Dont minespoof some blocks
		Block[] dontMine = {Blocks.WEB};
		for (Block block : dontMine) {
			if (getBlock(mc.objectMouseOver.getBlockPos()) == block) {
				return false;
			}
		}
		
		return true;
	}
	
	public static int getPickaxeSlot() {
		Item[] picks = {Items.DIAMOND_PICKAXE, Items.GOLDEN_PICKAXE, Items.IRON_PICKAXE, Items.STONE_PICKAXE, Items.WOODEN_PICKAXE};
		
		for (Item pick : picks) {
			if (InventoryUtil.hasHotbarItem(pick)) {
				return InventoryUtil.getSlot(pick);
			}
		}
		
		return -1;
	}
    
    public static class CancelForceRotation {
    	public static CancelForceRotation instance = new CancelForceRotation();
    	
        @EventHandler
        private Listener<PacketEvent> packetEvent = new Listener<>(event -> {
        	if (mc.player == null) {
    			return;
        	}
        	
        	if (event.packet instanceof SPacketPlayerPosLook) {
        		event.cancel();
        		
        		SPacketPlayerPosLook packet = (SPacketPlayerPosLook)event.packet;
        		mc.player.setPosition(packet.getX(), packet.getY(), packet.getZ());
        		mc.player.motionY = 0;
        		
        		float[] rotations = RotationUtil.getRotations(new Vec3d(getPlayerPos().add(0, -1, 0)).add(0.5, 0.5, 0.5).add(new Vec3d(EnumFacing.UP.getDirectionVec()).scale(0.5)));
        		
                mc.getConnection().sendPacket(new CPacketConfirmTeleport(packet.getTeleportId()));
                mc.getConnection().sendPacket(new CPacketPlayer.PositionRotation(mc.player.posX, mc.player.getEntityBoundingBox().minY, mc.player.posZ, rotations[0], rotations[1], false));
        	}
        });
    }
}
