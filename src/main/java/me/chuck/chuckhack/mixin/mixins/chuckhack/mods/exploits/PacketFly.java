package me.chuck.chuckhack.mixin.mixins.chuckhack.mods.exploits;

import me.chuck.chuckhack.Mod;
import me.chuck.chuckhack.events.bus.EventHandler;
import me.chuck.chuckhack.events.bus.Listener;
import me.chuck.chuckhack.events.other.PacketEvent;
import me.chuck.chuckhack.events.player.PlayerMotionUpdateEvent;
import me.chuck.chuckhack.gui.Group;
import me.chuck.chuckhack.gui.Mode;
import me.chuck.chuckhack.gui.Setting;
import me.chuck.chuckhack.mods.movement.EntitySpeed;
import me.chuck.chuckhack.mods.render.Freecam;
import me.chuck.chuckhack.utils.Timer;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraft.util.math.Vec3d;

public class PacketFly extends Mod {
	private static Timer antikickTimer = new Timer();
	
	public static Setting speed = new Setting(Mode.DOUBLE, "Speed", 0.031, "Higher = faster");
	public static Setting downSpeed = new Setting(Mode.DOUBLE, "DownSpeed", 0.1, "How much to go down every now and then", "To prevent getting kicked");
	public static Setting antikickMs = new Setting(Mode.INTEGER, "AntiKickMs", 1000, "AntiKick timer in milliseconds", "How often it makes it go down a bit");
	public static Setting teleportAmount = new Setting(Mode.INTEGER, "Teleport", 1337, "How much to teleport up", "To make it work");
	
	public PacketFly() {
		super(Group.EXPLOITS, "PacketFly", "Fly using packet exploit");
	}
	
    @EventHandler
    public Listener<PlayerMotionUpdateEvent> playerMotionUpdateEvent = new Listener<>(event -> {
        mc.player.setVelocity(0, 0, 0);
        event.cancel();
        
        if (mc.player.ticksExisted < 20) {
        	return;
        }
        
        if (!antikickTimer.hasPassed(antikickMs.intValue())) {
        	if (mc.gameSettings.keyBindJump.isKeyDown()) {
        		mc.player.motionY = speed.doubleValue();
        	} else if (mc.gameSettings.keyBindSneak.isKeyDown()) {
        		mc.player.motionY = -speed.doubleValue();
        	}
        } else {
        	antikickTimer.reset();
        	if (!isSolid(getPlayerPos())) {
        		mc.player.motionY = -downSpeed.doubleValue();
        	}
        }

        if (EntitySpeed.isInputting()) {
            double yawRad = Math.toRadians(mc.player.rotationYaw - Freecam.getRotationFromVec(new Vec3d(-mc.player.moveStrafing, 0.0, mc.player.moveForward))[0]);
    		mc.player.motionX = -Math.sin(yawRad) * speed.doubleValue();
    		mc.player.motionZ = Math.cos(yawRad) * speed.doubleValue();
        }
        
        mc.player.connection.sendPacket(new CPacketPlayer.PositionRotation(mc.player.posX + mc.player.motionX, mc.player.posY + mc.player.motionY, mc.player.posZ + mc.player.motionZ, mc.player.rotationYaw, mc.player.rotationPitch, mc.player.onGround));

        double y = mc.player.posY + mc.player.motionY;
        y += teleportAmount.intValue();
        mc.player.connection.sendPacket(new CPacketPlayer.PositionRotation(mc.player.posX + mc.player.motionX, y, mc.player.posZ + mc.player.motionZ, mc.player.rotationYaw, mc.player.rotationPitch, mc.player.onGround));
    });
    
    @EventHandler
    public Listener<PacketEvent> onPacket = new Listener<>(event -> {
		if (event.packet instanceof SPacketPlayerPosLook && mc.currentScreen == null) {
            SPacketPlayerPosLook packet = (SPacketPlayerPosLook)event.packet;
            mc.player.connection.sendPacket(new CPacketConfirmTeleport(packet.getTeleportId()));
            mc.player.connection.sendPacket(new CPacketPlayer.PositionRotation(packet.getX(), packet.getY(), packet.getZ(), packet.getYaw(), packet.getPitch(), false));
            mc.player.setPosition(packet.getX(), packet.getY(), packet.getZ());

            event.cancel();
		}
    });
}
